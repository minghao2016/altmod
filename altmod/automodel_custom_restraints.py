from __future__ import print_function
import csv
import time

from modeller import physical, group_restraints
from modeller import alignment, forms, features
from modeller.automodel import automodel

from .altmod_utils import hddr_groups, custom_argmin, get_modeller_atom, get_modeller_dist


allowed_mt_weights_schemes = ("uniform",
                              "rosetta",
                              "no_weight",
                              "optimal",
                              "optimal_st",)

class Automodel_custom_restraints(automodel):
    """
    'automodel' child class used to perform homology model building by changing
    the default parameters for homology-derived distance restraints (HDDR) generated
    by MODELLER.
    """

    def set_defaults(self):
        """
        Overrides the original 'set_defaults' method.
        """

        super(Automodel_custom_restraints, self).set_defaults()

        print("@ Setting 'Automodel_custom_restraints' defaults.")

        # This will be set as 'True' only when the 'set_custom_hddr_options' method
        # has been called.
        self._has_custom_hddr_options = False


    def homcsr(self, exit_stage):
        """
        Overrides the original 'homcsr' method in order to edit the restraints file
        generated by MODELLER.
        """
        # Build an initial model PDB file and a .rsr file.
        self.build_initial_files(exit_stage)

        # Rebuild the restraints files.
        self.rebuild_restraints_file()


    def build_initial_files(self, exit_stage=0):
        """
        Calls the original 'homcsr' method from the 'automodel' class. This will
        build an initial PDB file of the model and a restraints file. Also parses
        the initial PDB and restraints files.
        """

        # Call the parent class method.
        automodel.homcsr(self, exit_stage)

        #----------------------------------------------------------------
        # Parse the initial model PDB file to get the indices of atoms. -
        #----------------------------------------------------------------

        # Dictionary to map atom serial numbers to residue numbers.
        self.atm_to_res_dict = {}
        # Dictionary to map atom serial numbers to their types.
        self.atm_type_dict = {}
        # Dictionary to map the residue number and the atom type of the model to the atom serial
        # number.
        self.res_to_atm_dict = {}

        m_fh = open(self.inifile, "r")
        for line in m_fh:
            if not line.startswith("ATOM"):
                continue
            atm_type = line[11:16].replace(" ", "")
            atm_num = int(line[5:11].replace(" ", ""))
            res_type = line[17:20]
            res_num = int(line[22:26])
            chain = line[20:22].replace(" ", "")
            self.atm_to_res_dict[atm_num] = res_num
            self.atm_type_dict[atm_num] = atm_type
            if not res_num in self.res_to_atm_dict:
                self.res_to_atm_dict[res_num] = {atm_type: atm_num}
            else:
                self.res_to_atm_dict[res_num][atm_type] = atm_num

        m_fh.close()


        #-----------------------------------------------------------
        # Parse the restraints file used by the 'automodel' class. -
        #-----------------------------------------------------------

        # Set of atom pairs actually involved in HDDRs.
        self.restrained_atm_couples = set()
        # Set of residue pairs involved in HDDRs.
        self.restrained_res_couples = set()
        # A dictionary with all restraints per group.
        self.hddr_dict = dict([(grp, []) for grp in hddr_groups])
        self.hddr_dict["all"] = []

        r_fh = open(self.csrfile, "r")
        for line in r_fh:
            if not line.startswith("R"):
                continue
            rst_fields = line.split()

            # Gets the atoms and residues pairs on which some HDDR was produced by MODELLER.
            group = rst_fields[4]
            if group in hddr_groups:
                atm_1 = int(rst_fields[8])
                atm_2 = int(rst_fields[9])

                self.restrained_atm_couples.add((atm_1, atm_2))
                self.restrained_atm_couples.add((atm_2, atm_1))

                self.restrained_res_couples.add((self.atm_to_res_dict[atm_1], self.atm_to_res_dict[atm_2]))
                self.restrained_res_couples.add((self.atm_to_res_dict[atm_2], self.atm_to_res_dict[atm_1]))

                self.hddr_dict[group].append((atm_1, atm_2))
                self.hddr_dict["all"].append((atm_1, atm_2))

        r_fh.close()


    def _initialize_mod_tem_mapping(self):
        """
        Maps each residue number of the model to the correspondent MODELLER
        residue object of the template.
        """

        # Initializes an alignment object stored in an attribute.
        self._altmod_aln = self.read_alignment()

        # Each template will have its own dictionary.
        self.mod_tem_ali_dict_list = [{} for i in self.knowns]

        for tem_idx, tem_name in enumerate(self.knowns):

            modeller_mod_seq = self._altmod_aln[self.sequence]
            modeller_tem_seq = self._altmod_aln[tem_name]

            # Iterates over all the positions of the target-template alignment.
            for pos in self._altmod_aln.positions:
                mod_pos = pos.get_residue(modeller_mod_seq)
                tem_pos = pos.get_residue(modeller_tem_seq)
                if mod_pos != None and tem_pos != None:
                    self.mod_tem_ali_dict_list[tem_idx][mod_pos.index] = tem_pos


    def get_template_distance(self, atm_1, atm_2, template_index):
        """
        Given two atom serial numbers of the model, returns the distance observed
        in one of the templates equivalent atoms.

        # Arguments
            atm_1: first model atom serial number.
            atm_2: second model atom serial number.
            template_index: numeric index of the template to consider (the templates
                indices are the ones in the template list provided in the 'knowns'
                argument in the 'automodel' class).

        # Returns
            The distance between the template atoms equivalent to 'atm_1' and
            'atm_2'. If 'atm_1' or 'atm_2' do not have an equivalent atom in the
            template (for instance, because the residues to which they belong are
            not aligned to template residues or because the aligned template
            residue may have different atom types), it returns 'None'
        """

        if not hasattr(self, "atm_to_res_dict"):
            raise ValueError("Use the 'build_initial_files' or 'homcsr' methods (which will map model residues to the template ones) before using this method.")

        if not hasattr(self, "mod_tem_ali_dict_list"):
            self._initialize_mod_tem_mapping()

        tem_res_1 = self.mod_tem_ali_dict_list[template_index][self.atm_to_res_dict[atm_1]]
        tem_res_2 = self.mod_tem_ali_dict_list[template_index][self.atm_to_res_dict[atm_2]]

        atm_1_type = self.atm_type_dict[atm_1]
        atm_2_type = self.atm_type_dict[atm_2]

        tem_atm_1 = get_modeller_atom(tem_res_1, atm_1_type)
        tem_atm_2 = get_modeller_atom(tem_res_2, atm_2_type)

        if tem_atm_1 != None and tem_atm_2 != None:
            return get_modeller_dist(tem_atm_1, tem_atm_2)
        else:
            return None


    def set_custom_hddr_options(self, hddr_params_filepaths,
                                sigma_col,
                                location_col=None,
                                remove_missing_hddrs=True,
                                st_min_sigma_val=0.05,
                                mt_min_sigma_val=0.05,
                                mt_weights_scheme="optimal_st",
                                mt_rosetta_k=2.5,
                                mt_use_splines=True,
                                atom_i_col="MOD_ATOM_INDEX_I",
                                atom_j_col="MOD_ATOM_INDEX_J"):
        """
        Sets the custom HDDR parameters. It must be called before using the 'make'
        method to build 3D models.

        # Arguments
            hddr_params_filepaths: list of the HDDR parameters file paths. Each
                template must be associated with one (that is, if you use two
                templates, you have to supply a list of two HDDR parameter files).
                These HDDR parameters files must be in the CSV format.
            sigma_col: column in the .csv files where the custom sigma values for
                the HDDRs are stored.
            location_col: column in the .csv files where the custom location values
                for the HDDRs are stored. When performing single-template modeling,
                this argument is optional, since when it is set to 'None', the
                the default location parameters in the MODELLER .rsr file will be
                used. When performing multiple-template modeling, this argument
                is required, since when it is not possible to easily extract the
                location parameters from multi-Gaussian HDDRs stored in the default
                MODELLER .rsr file. Therefore the location parameters of
                multiple-template restraints must be provided by users (the
                'get_template_distance' method may prove useful to derived these
                parameters when writing your own HDDR parameter files).
            remove_missing_hddrs: By setting as 'True' this argument, those HDDRs
                in the MODELLER default .rsr file which do not have a correspondant
                row in the HDDR paramaters files, will be deleted. If you use HDDR
                parameter files lacking only a small fraction of HDDRs, it will not
                cause problems, but removing too many HDDRs usually results in poor
                side chain modeling and bad stereochemistry, so use this option
                carefully.
            st_min_sigma_val: minimum allowed sigma value for single-template HDDRs.
                Custom sigma values being lower than it, will be converted to it.
                Using values of less than 0.05 for this argument is dangerous,
                since such low sigma values enourmously increase the object function
                value of a model and stop the 3D model building process of MODELLER.
            mt_min_sigma_val: minimum allowed sigma value for multiple-template
                HDDRs.
            mt_weights_scheme: weighting scheme to be adopted for multiple-template
                HDDRs. The following schemes are available:
                    "uniform": each template is given the same contribution in a
                        HDDR.
                    "rosetta": weighting scheme adopted in RosettaCM. A template
                        is given a weight inversely proportional to its sigma value
                        (the lower its sigma, the higher its weight). See:
                        'Incorporation of evolutionary information into Rosetta
                        comparative modeling. Thompson J, Baker D., Proteins.
                        2011 Aug;79(8):2380-8.
                    "no_weight": all templates are given a weight of 1.
                    "optimal": the template with the lowest sigma is given a weight
                        of 1 and the rest a weight of 0.
                    "optimal_st": similar to "optimal", but instead of writing on
                        the .rst file a  multiple-Gaussian HDDR in which the
                        template with the lowest sigma has a weight of 1, this
                        will write a single-Gaussian HDDR only for that template.
            mt_rosetta_k: if the 'mt_weights_scheme' is set to "rosetta", this
                parameter will control the extent to which templates with lower
                sigma values dominate over the others.
            mt_use_splines: if set to 'True', the custom multiple-template Gaussian
                HDDRs (which in the .rsr files have a code of "4") will be
                converted to splines form (which have a code of "10"). This is what
                MODELLER does by default. Setting this as 'True' is usually convenient,
                because when splines are not used, unless 'mt_min_sigma_val' is
                higher than ~0.2, the objective the multi-Gaussian HDDRs will cause
                the objective function of models to acquire very large values
                and stop the 3D model building process. Since converting
                multi-Gaussian HDDRs to splines does not make a change the quality
                of 3D models, it is safer to use splines.
            atom_i_col: column in the .csv files that stores the serial number of
                the first model atom on which an HDDR is acting.
            atom_j_col: column in the .csv files that stores the serial number of
                the second model atom on which an HDDR is acting.
        """

        # HDDR parameters files.
        if not isinstance(hddr_params_filepaths, list):
            if isinstance(hddr_params_filepaths, tuple):
                hddr_params_filepaths = list(hddr_params_filepaths)
            elif isinstance(hddr_params_filepaths, basestring):
                hddr_params_filepaths = [hddr_params_filepaths]
            else:
                raise TypeError("Invalid type for 'hddr_params_filepaths': %s." % type(hddr_params_filepaths))
        if len(hddr_params_filepaths) != len(self.knowns):
            raise ValueError("Invalid number of hddr params files provided (%s), it must be equal to the number of templates used (%s)." % (len(hddr_params_filepaths), len(self.knowns)))
        self.hddr_params_filepaths = hddr_params_filepaths

        self.sigma_col = sigma_col
        if len(self.knowns) > 1 and location_col == None:
            raise ValueError("A 'location_col' must be defined in the 'set_custom_hddr_options' when using multiple-templates.")
        self.location_col = location_col
        self.remove_missing_hddrs = remove_missing_hddrs

        # Minimum allowed value for sigma values of HDDRs.
        self.st_min_sigma_val = st_min_sigma_val
        self.mt_min_sigma_val = mt_min_sigma_val

        # Multiple-template HDDRs parameters.
        if not mt_weights_scheme in allowed_mt_weights_schemes:
            raise KeyError("Unknown 'mt_weights_scheme': %s. Must be one of: %s ." % (mt_weights_scheme,
                                                                                      repr(allowed_mt_weights_schemes)))
        self.mt_weights_scheme = mt_weights_scheme
        self.mt_rosetta_k = mt_rosetta_k
        self.mt_use_splines = mt_use_splines

        # Atom columns.
        self.atom_i_col = atom_i_col
        self.atom_j_col = atom_j_col

        self._has_custom_hddr_options = True


    def rebuild_restraints_file(self):
        """
        This method will edit the HDDRs in default restraints file (.rsr) of
        MODELLER using the parameters found in the files supplied in the
        'hddr_params_filepaths' argument of the 'set_custom_hddr_options' method.
        It will scan for all HDDRs in the default restraints file generated by
        MODELLER (or in a custom restraints file supplied through the 'csrfile'
        argument of the "automodel" classes). For each HDDR acting between two
        atoms it finds in the .rsr file, it will search for a corresponding line
        in the .csv HDDR parameters files. The .csv rows which have the same atom
        serial numbers of the HDDR present in the original .rst file will be
        selected and their sigma and location parameters will be used to edit the
        the original HDDR line in the .rsr file.
        If the method does not find any matching row, by default it will delete
        the HDDR from the .rsr file (but this behaviour may be changed using
        the 'remove_missing_hddrs' argument of the 'set_custom_hddr_options' method).
        In case you have multiple templates, this method will look for a matching
        row in each HDDR parameters file you provide (each template must be
        associated to a parameter file). If it finds only one row, it will edit
        the original HDDR line by converting it to a single-template HDDR line (even
        if in the original .rsr file it was a multiple-template HDDR line). It if
        finds more than one row, it will edit the original HDDR line by converting
        it to multiple-template HDDR line (even if in the original .rsr file it was
        a single-template HDDR line).
        This method does not edit directly the original .rsr file, but it makes a
        copy of it (the path of this copy will be set in the 'csrfile' attribute
        of the "automodel" object).
        """

        if not self._has_custom_hddr_options:
            raise ValueError("Please use the 'set_custom_hddr_options' method before rebuilding the restraints file.")

        print("\n# Editing the default MODELLER restraints file to insert custom parameters.")


        #-------------------------------------
        # Parses the HDDR parameters files.  -
        #-------------------------------------

        pair_data_dict_list = []

        t1 = time.time()

        for hddr_params_filepath in self.hddr_params_filepaths:

            pair_data_dict = {}

            # Parses the HDDR params filepath.
            with open(hddr_params_filepath, "r") as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    atm_1 = int(row[self.atom_i_col])
                    atm_2 = int(row[self.atom_j_col])
                    sigma = abs(float(row[self.sigma_col]))
                    loc = float(row[self.location_col])
                    pair_data_dict[(atm_1, atm_2)] = (loc, sigma)

            pair_data_dict_list.append(pair_data_dict)

        t2 = time.time()
        print("- To parse, it took", t2-t1)


        #---------------------------------------
        # Parses the original restraints file. -
        #---------------------------------------

        # Lines of the new restraints file.
        new_rst_file_lines = []
        # Lines of the old restraints file containing HDDRs.
        hddr_rst_lines = []

        # List of atom couples on which an HDDR is acting according to the restraints
        # file.
        restrained_atm_couples = []

        r_fh = open(self.csrfile, "r")
        for line_idx, line in enumerate(r_fh):

            if line_idx == 0:
                new_rst_file_lines.append(line)
                continue

            # Gets the HDDRs present in the restraints file. These will be edited using custom
            # parameters.
            rst_fields = line.split()
            if rst_fields[4] in hddr_groups:
                atm_1 = int(rst_fields[8])
                atm_2 = int(rst_fields[9])
                restrained_atm_couples.append((atm_1, atm_2))
                hddr_rst_lines.append((rst_fields[4], line))

            # Maintain as the same all the non-HDDR restraints.
            else:
                new_rst_file_lines.append(line)

        r_fh.close()


        #-------------------------------------------------------------------
        # Actually rebuild the HDDR lines in the MODELLER restraints file. -
        #-------------------------------------------------------------------

        # Process one HDDR group per time.
        for hddr_grp in hddr_groups:

            restraints_rebuilt = 0
            restraints_errors = 0

            # Filter the HDDRs by their group.
            sel_restrained_atm_couples = []
            sel_hddr_rst_lines = []
            for t, l in zip(restrained_atm_couples, hddr_rst_lines):
                if l[0] == hddr_grp:
                    sel_restrained_atm_couples.append(t)
                    sel_hddr_rst_lines.append(l)

            print("- Editing restraints group %s." % hddr_grp)

            # Actually edit the HDDRs lines.
            for (atm_1, atm_2), (rst_grp, original_hddr_line) in zip(sel_restrained_atm_couples, sel_hddr_rst_lines):

                # print atm_1, atm_2

                original_fields = original_hddr_line.split()

                # Selects those rows from the HDDR params files where the current
                # atoms are found.
                all_found_rows = []
                for pair_data_dict in pair_data_dict_list:

                    if (atm_1, atm_2) in pair_data_dict:
                        all_found_rows.append(pair_data_dict[(atm_1, atm_2)])
                    elif (atm_2, atm_1) in pair_data_dict:
                        all_found_rows.append(pair_data_dict[(atm_2, atm_1)])
                    else:
                        continue

                # A single template was found from the HDDR params files.
                if len(all_found_rows) == 1:

                    row = all_found_rows[0]
                    location = row[0]
                    sigma = row[1]

                    # Get the sigma values.
                    rst_std = self._get_std(sigma)
                    rst_std = round(rst_std, 4)

                    # The original HDDR was single-template.
                    if original_fields[1] == "3":
                        # Take the location value already present in the restraints file.
                        if self.location_col == None:
                            rst_loc = float(original_fields[-2])
                        # Take the location specified in the HDDR params file.
                        else:
                            rst_loc = round(location, 4)
                            # Use the original location if using optimal HDDRs.
                            if hasattr(self, "use_target_distances") and not self.use_target_distances:
                                rst_loc = float(original_fields[-2])

                    # The original HDDR was multiple-template.
                    else:
                        rst_loc = round(location, 4)

                    new_rst_fields = self._get_st_rst_fields(atm_1, atm_2, rst_loc, rst_std, rst_grp) #, row=row, pdf=pdf)
                    new_rst_file_lines.append("   ".join(new_rst_fields) + "\n")

                    restraints_rebuilt += 1

                # Multiple templates were found from the HDDR params files.
                elif len(all_found_rows) > 1:

                    new_rst_fields = self._get_mt_rst_fields(atm_1, atm_2, all_found_rows, rst_grp, mt_merge_rst=True)
                    new_rst_file_lines.append("   ".join(new_rst_fields) + "\n")

                    restraints_rebuilt += 1

                # No corresponding line were found.
                else:
                    restraints_errors += 1
                    # Still use the default MODELLER HDDR.
                    if not self.remove_missing_hddrs:
                        new_rst_file_lines.append(original_hddr_line)

            if restraints_errors != 0:
                if self.remove_missing_hddrs:
                    default_rst_message = ""
                else:
                    default_rst_message = " Using the default restraints provided in .rsr file."

                print("- Warning: %s of %s restraints of group %s could not be rebuilt.%s" % (restraints_errors, len(sel_hddr_rst_lines), rst_grp, default_rst_message))


        # Write the new restraints file.
        new_rst_filepath = self.csrfile + ".edit"
        new_restr_fh = open(new_rst_filepath, "w")
        new_restr_fh.writelines(new_rst_file_lines)
        new_restr_fh.close()
        self.csrfile = new_rst_filepath

        # Converts multiple-template Gaussian HDDRs in the spline form.
        if len(self.knowns) > 1 and self.mt_use_splines:
            self.spline_mt_gaussian_hddr()

        self.rd_restraints()


    def spline_mt_gaussian_hddr(self):
        """
        Converts the multiple-templates multi-gaussian HDDRs in splines. This allows
        to use for these restraints sigma values < 0.10 A (which otherwise would
        increase too much the objective function and stop the 3D model building
        phase of MODELLER).
        """
        self.rd_restraints()
        for phys_grp in (physical.ca_distance,
                         physical.n_o_distance,
                         physical.sd_mn_distance,
                         physical.sd_sd_distance):
            # Check: https://salilab.org/modeller/manual/node223.html
            self.restraints.spline(forms.multi_gaussian, features.distance, phys_grp,
                                   spline_range=4.0, spline_dx=0.35, edat=self.env.edat)
            self.restraints.condense()
        self.restraints.write(file=self.csrfile)


    def _get_std(self, sigma, use_mt=False):
        return self._adjust_value(sigma, use_mt=use_mt)


    def _adjust_value(self, value, use_mt=False):
        new_value = abs(value)

        # Min clipping.
        min_val = self._get_min_val(use_mt)
        if min_val != None and new_value < min_val:
            new_value = min_val

        return new_value

    def _get_min_val(self, use_mt=False):
        if not use_mt:
            return self.st_min_sigma_val
        else:
            return self.mt_min_sigma_val


    def _get_st_rst_fields(self, atm_1, atm_2, mean, std, rst_grp):
        """
        Forms the fields of a single-template Gaussian HDDR line to be used in
        MODELLER restraints files.
        """
        new_rst_fields = ["R", "3", "1", "1", rst_grp, "2", "2", "1", str(atm_1), str(atm_2)]
        new_rst_fields.append(str(mean))
        new_rst_fields.append(str(std))
        return new_rst_fields


    def _get_mt_rst_fields(self, atm_1, atm_2, found_rows, rst_grp, mt_merge_rst=True):
        """
        Forms the fields of a multiple-template Gaussian HDDR line.
        """
        n_templates = len(found_rows)

        # Get the means for each template.
        d_prime_list = [row[0] for row in found_rows]
        # Get the standard deviations.
        rst_stds = [self._get_std(row[1], use_mt=True) for row in found_rows]

        # Get the weights.
        if self.mt_weights_scheme == "uniform":
            weights = [1.0/float(n_templates) for row in found_rows]

        elif self.mt_weights_scheme == "rosetta":
            std_sum = sum([rst_std**-self.mt_rosetta_k for rst_std in rst_stds])
            weights = [(rst_std**-self.mt_rosetta_k)/std_sum for rst_std in rst_stds]

        elif self.mt_weights_scheme == "no_weight":
            weights = [1.0]*len(rst_stds)

        elif self.mt_weights_scheme == "optimal":
            weights = [0.0]*len(rst_stds)
            weights[custom_argmin(rst_stds)] = 1.0

        elif self.mt_weights_scheme == "optimal_st":
            min_std_id = custom_argmin(rst_stds)
            std = round(rst_stds[min_std_id], 4)
            mean = round(d_prime_list[min_std_id], 4)
            rst_field = self._get_st_rst_fields(atm_1, atm_2, mean, std, rst_grp)
            return rst_field

        elif self.mt_weights_scheme == "function":
            raise NotImplementedError()


        # Actually adds the restraints line fields.
        if mt_merge_rst:
            # Use a multi-gaussian.
            new_rst_fields = ["R", "4", str(n_templates), "1", str(rst_grp), "2" , str(n_templates*3), "1", str(atm_1), str(atm_2)]
            new_rst_fields.extend([str(round(v, 4)) for v in weights + d_prime_list + rst_stds])

        else:
            raise NotImplementedError()

        return new_rst_fields
